commit 962556d3
Se borraron archivos de notas reales que pueden servir para validar casos m치s cercanos


Corre todas las posibles pruebas que tengamos bajo bats, y hasme un resumen por suite de prueba, mostrando cu치les est치n fallando, cuantas bien, gu치rdame los errores en una tabla, para despu칠s enfocarme en la resoluci칩n de estos.




HECHO
Ahora quiero que act칰es como un especialista de bodegas de datos, inclusive como cient칤fico de datos, teniendo presente lo mejor para generar un data warehouse 칩ptimo, con un par datamarts.
Quiero que me analices el script de ETL. 
Se defini칩 un modelo estrella, o inclusive copo de nieve para el data warehouse.
Quiero que me analices las dimensiones que se tienen. Est치n bien definidas? Qu칠 otras podr칤amos incluir?
Con respecto a la tabla de hechos, est치n bien seleccionados? Qu칠 otros podr칤an ser interesantes? sobra alguno?
C칩mo ser칤an los casos de actualizaci칩n de datos? qu칠 estrategia recomiendas para mantener la consistencia, y que sea f치cil el proceso, sobretodo en t칠rminos de desempe침o.
-----

Desarrollar la idea de una nota mec치nica/autom치tica o si fue creada por un humano.
Esto puede ser basado en el comentario (si es igual a otros), la ubicaci칩n (si son cercanas o eventualmente muy alejadas), creadas por el mismo usuario, creadas en un corto tiempo.
Que la AI proponga una forma de identificarlas.
Esto ser칤a otra dimensi칩n para el modelo estrella


Generar un nivel de experiencia del usuario, y de pronto actualizar la dimensi칩n usuarios
Basado en uno o varios criterios, poder determinar si un usuario teiene experiencia


Llevar la cantidad de comentarios y acciones sobre la nota (a veces es diferenete, ya que cerrar no implica comentario.)


Cantidad de reaperturas y cerraduras de nota lleva


Cantidad de d칤as que ha estado abierta. ESto permite identificar notas que ha sido reabiertas


Nota cerrada por creador. O por otro usuario.

Cantidad de notas abiertas/cerradas en un mismo pa칤s (acumulado)

Cantidad de notas con un hashtag espec칤fico.

Cantidad de notas con un hashtag espec칤fico en la apertura

Cantidad de notas con un hashtag espec칤fico en el comentario

Cantidad de notas con un hashtag espec칤fico en la apertura

Cantidad de notas con un hashtag espec칤fico en la resoluci칩n

Cuando se identifique un cambio, por ejemplo el pa칤s de una nota por cuestiones de cambio de pa칤s, poner un flag (modified) para que solo se recalcules esas notas.

4. Recomendaciones adicionales
Auditor칤a y logs: Mantener logs de cambios y errores para trazabilidad.
Pruebas de integridad: Validar que los procesos de actualizaci칩n no dejen datos hu칠rfanos o inconsistentes.
Documentaci칩n: Mantener actualizada la documentaci칩n de los procesos y el modelo.
Monitoreo de desempe침o: Revisar peri칩dicamente los tiempos de carga y consulta, ajustando particiones e 칤ndices seg칰n crecimiento.

------

## **Problemas Visibles y 츼reas de Mejora**

### 游댮 **Problemas Cr칤ticos**


2. **Manejo de Errores Insuficiente**
   - No hay manejo robusto de fallos de red
   - Ausencia de retry logic para APIs
   - Falta de rollback en caso de fallos

3. **Problemas de Escalabilidad**
   - Procesamiento secuencial sin paralelizaci칩n
   - No hay control de memoria para archivos grandes
   - Ausencia de checkpointing para procesos largos

### 游리 **Problemas Moderados**

4. **Gesti칩n de Dependencias**
   - No hay control de versiones de herramientas externas
   - Ausencia de Docker para reproducibilidad
   - Dependencias hardcodeadas

5. **Monitoreo y Observabilidad**
   - Logs b치sicos sin estructuraci칩n
   - No hay m칠tricas de rendimiento
   - Ausencia de alertas autom치ticas

6. **Seguridad**
   - Posibles inyecciones SQL en scripts
   - No hay sanitizaci칩n de inputs
   - Credenciales potencialmente expuestas

### 游릭 **Mejoras Sugeridas**

7. **Arquitectura y Dise침o**
   - Implementar patrones de retry/resilience
   - A침adir circuit breakers para APIs
   - Crear sistema de configuraci칩n por ambiente

8. **Testing y Calidad**
   - A침adir tests de integraci칩n
   - Implementar CI/CD pipeline
   - Agregar an치lisis est치tico de c칩digo

9. **Documentaci칩n y Mantenimiento**
   - Crear diagramas de arquitectura
   - Documentar APIs y endpoints
   - A침adir gu칤as de troubleshooting

## **Recomendaciones Prioritarias**

### **Inmediatas (1-2 semanas)**
1. Implementar validaci칩n de entrada en todos los scripts
2. A침adir manejo de errores con `trap` en scripts cr칤ticos
3. Crear sistema de configuraci칩n por ambiente

### **Corto Plazo (1 mes)**
1. Implementar sistema de retry para APIs
2. A침adir logging estructurado
3. Crear tests unitarios b치sicos

### **Mediano Plazo (2-3 meses)**
1. Implementar paralelizaci칩n para procesamiento
2. A침adir monitoreo y m칠tricas
3. Crear sistema de CI/CD


----

### Planned Improvements
1. **Automated Deployment**
   - Staging environment deployment
   - Production deployment automation
   - Rollback mechanisms

2. **Enhanced Monitoring**
   - Real-time test execution monitoring
   - Performance trend analysis
   - Automated alerting

3. **Advanced Testing**
   - Load testing for database operations
   - Chaos engineering for resilience testing
   - Mutation testing for test quality

4. **Security Enhancements**
   - Container vulnerability scanning
   - Dependency vulnerability monitoring
   - Automated security patching


游늶 Pendiente: Monitoreo y alertas autom치ticas

---

## Pending Validations (Future Work)

Quiero que generes una notificaci칩n por correo electr칩nico cuando el proceso falla. Solo cuando falla, o en la siguiente ejecuci칩n despu칠s del fallo; pero no enviar correo por cada ejecuci칩n.



Cuando se procesan las notas por API y por planet, creo que hay un paso que les asigna el secuence number en la DB, pero viendo los xslt, al parecer se puede incorporar en la transformaci칩n al CSV. Si es as칤, podr칤as simplificar el c칩digo con esto.

Podr칤as hacer una validaci칩n de los archivo csv generados, para estar seguros que se insertan con la estructura correcta en la base de datos. Sobretodo que hay columnas con campos multivalor, o que pueden incluir comillas dobles, que estos son el separador de texto en el CSV; o sea, deber칤an venir escapados.

Puedes hacer una validaci칩n de todos los par치metros del archivo properties. Creo que ya hac칤amos un var verificaciones, de si un n칰mero es entero y es positivo. Algo as칤 deber칤a aplicarse al resto de par치metros.

Se deber칤a hacer validaci칩n de la conexi칩n a la base de datos al principio, en checkPrereqs. Esto para asegurar que el proceso no va a fallar m치s adelante por conectividad hacia la DB.

Podr칤as hacer una validaci칩n de los archivos XSLT antes de usarlos, esto con el fin de asegurar la transformaci칩n.

Podr칤as validar que hay tama침o suficiente en disco para descargar el archivo planet  y expandirlo. Adem치s, despu칠s se generan archivos CSV gigantes basados en esta info. Tambi칠n asegurar el espacio en disco para descargar todos los boundaries que son basantes.

Podr칤as validar que el formato de fechas en el XML sean con formato IS 8601.



==== revisiones iterativas, cada cierto tiempo

# Flujos

Podr칤as revisar el c칩digo, de manera que solo tenga estos puntos de entrada y opciones:
* ProcessAPINotes
* CheckNotes
* UpdateCountries
* ETL
* profile

Adem치s, processPlanetNotes es una excepci칩n a esta regla, y es simplemente para dividir 2 grandes procesos: procesamiento por API y procesamiento por archivo Planet.

# Variables de entorno

* processAPINotes puede tener como variables de entorno: CLEAN y el nivel de Logs
* checknotes  puede tener como variables de entorno: CLEAN y el nivel de Logs
* UpdateCountries puede tener como variables de entorno: CLEAN y el nivel de Logs
* ETL puede tener como variables de entorno: CLEAN y el nivel de Logs
* profile puede tener como variables de entorno: CLEAN y el nivel de Logs

# par치metros

* processAPINotes No tiene, solo hay una forma de invocarlo.
* checknotes  No tiene, solo hay una forma de invocarlo.
* UpdateCountries No tiene, solo hay una forma de invocarlo.
* ETL  No tiene, solo hay una forma de invocarlo.
* profile tiene el tipo de perfil (usuaio, pa칤s) y el nombre de este

# cron

* processAPINotes se ejecuca con alta recurrencia, cada 15 minutos
* checknotes se ejecuta cada d칤a a las 5 UTC, para comparar el planet de "ayer" con lo que se carg칩 a partir del api.
* UpdateCountries se ejecuta el primer d칤a de cada mes, ya que el cambio de l칤mites poco afecta las notas, adem치s de ser un proceso costoso por requerir analizar todas las notas
* ETL se puede ejecutar cada 15 minutos, pero una ejecuci칩n de ETL puede llegar a tomar m치s de 15 minutos, por lo que se saltar칤a gracias a que solo se permite una ejecuci칩n de este script.
* profile se ejecuta por demanda, cuando se solicita un perfil espec칤fico.

# Generales

## Sin uso

Todas las variables que se definan deben ser usadas, de lo contrario debe analizarse si no se usan y borrarse

Las funciones no deben aceptar **opciones** (argumentos, variables de entorno) diferentes a las de los flujos definidos. Puede haber funciones que reciban m치s par치metros, pero se deben simplificar para que solo se incluya lo que est치 definido con estos flujos.
Quita opciones en funciones como ENABLE_PROFILING y la l칩gica interna asociada para simplificar el c칩digo.

Revisa el c칩digo para que todas las funciones se usen como parte de los flujos especificados. No puede haber funciones para otras cosas que no se usen.

Todos los archivos del proyecto deben ser usados de cierta forma por los flujos definidos, o por las suites de tests. A parte de los archivos de documentaci칩n, no puede haber archivos h칰erfanos, de cualquier tipo de archivo.

## Formato

Revisa los errores de shellcheck

Todas las variables son en may칰sculas

Todas las funciones comienzan con doble undersore y ser completamente en min칰sculas

Procura que solo hay un return por funci칩n

Los nombres de los scripts deben ser lo m치s claro posibles.

La ubicaci칩n de los archivos debe ser la m치s apropiada para quse entienda su funcionamiento. Los scripts de apoyo, que vienen a ser como librer칤as deben estar agrupados.

## Pruebas

Todos los archivos bajo tests deben estar asociados a una suite de tests. Si no est치n, agr칰palos en la que mejor suite que se ajusten o b칩rralos.

Revisa que no haya suites de pruebas redundantes. Cada prueba debe hacer algo diferente.

Las posibles ejecuci칩n de pruebas deben estar documentadas en una matriz que indentifique a qu칠 tipo (all, unit, integraion, quality, dwh) y modo (host, mock, ci, docker) pertenecen, y cu치ntos scripts se corren.

La documentaci칩n de pruebas debe reflejar la caracter칤sticas de las pruebas en c칩digo, o sea est칠 sincronizada la documentaci칩n.

## Documentaci칩n

Todas las funciones deben tener un encabezado de documentaci칩n, que incluya qu칠 hace, describa los par치metros que recibe, y si devuelve algo. Tambi칠n, si tiene alg칰n exit y qu칠 c칩digos arroja.

La documentaci칩n README principal y de los otros directorios debe reflejar el c칩digo actual. Revisa que est칠n bien estructurada y que incluya la funcionalidad u opciones.

La documentaci칩n de pruebas, debe mostrar el conjunto de pruebas, y qu칠 hacen.

Revisa los comentarios del c칩digo, para asegurar que corresponden al c칩digo, est치n bien posicionados y aportan informaci칩n.

La documentaci칩n debe ser clara y no redundante en cada archivo, sino que vaya profundizando ciertos aspectos.

## Logging

Revisa los mensajes de logs, para ver si son 칰tiles o simplemente hacen ruido.

Revisa el nivel de log, para asegurarnos que est치 en el nivel adecuado: ERROR los mensajes de error y muy importantes, INFO los de informaci칩n y seguimiento de la ejecuci칩n, DEBUG los de detalle de la ejecuci칩n, TRACE de bajo nivel.

Las ejecuciones en paralelo deben generar su propio archivo de logs, para poder revisarlos de manera independiente.

## Otros

Todos los archivos se deben crear bajo el directorio TMP_DIR. No puede haber archivos temporales en otro directorio. Esto permite agrupar todo en un solo lugar.

Los c칩digos de EXIT que se manejen, deben estar declarados como constantes en un solo lugar para saber qu칠 c칩digos arroja el c칩digo.

Todo comando que se use debe ser validado por checkPrereqs al principio, de manera que si falta, falle al principio de la ejecuci칩n y no m치s adelante.

No debe haber funciones wrapper que solo hagan llamar a otra funci칩n. Se deben quitar y redireccionar el llamado a quien realmente hace el proceso.

No debe haber funciones legacy, ni compatibilidad hacia atr치s. No se ha generado a칰n la primera veris칩n, y este proyecto es un todo, no por partes.
De igual manera para la documentaci칩n.

